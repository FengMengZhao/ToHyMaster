# 数据库设计(2017-Q4)

### 分库,分表的原则(垂直,水平)

**分库分表基本思想**

把原本存储于一个库的数据分块存储到多个库上，把原本存储于一个表的数据分块存储到多个表上。

**为什么要进行分库分表**

数据库中的数据量不一定是可控的，在未进行分库分表的情况下，随着时间和业务的发展，库中的表会越来越多，表中的数据量也会越来越大，相应地，数据操作，增删改查的开销也会越来越大；另外，由于无法进行分布式式部署，而一台服务器的资源（CPU、磁盘、内存、IO等）是有限的，最终数据库所能承载的数据量、数据处理能力都将遭遇瓶颈。

**垂直分表**

垂直分表在日常开发和设计中比较常见，通俗的说法叫做“大表拆小表”，拆分是基于关系型数据库中的“列”（字段）进行的。通常情况，某个表中的字段比较多，可以新建立一张“扩展表”，将不经常使用或者长度较大的字段拆分出去放到“扩展表”中.

**垂直分库**

垂直分库在“微服务”盛行的今天已经非常普及了。基本的思路就是按照业务模块来划分出不同的数据库，而不是像早期一样将所有的数据表都放到同一个数据库中。

**水平分表**

水平分表也称为横向分表，比较容易理解，就是将表中不同的数据行按照一定规律分布到不同的数据库表中（这些表保存在同一个数据库中），这样来降低单表数据量，优化查询性能。最常见的方式就是通过主键或者时间等字段进行Hash和取模后拆分。

> id取模分库分表：
1. `tmpvar = user_id % (库的数量 * 表的数量)`
2. `库 = tmpvar / 表的数量`
3. `表 = tmpvar % 表的数量`

**水平分库**

水平分库分表与上面讲到的水平分表的思想相同，唯一不同的就是将这些拆分出来的表保存在不同的数据库中。

**依据什么进行分库分表**

应该使用哪一种方式来实施数据库分库分表，这要看数据库中数据量的瓶颈所在，并综合项目的业务类型进行考虑。

如果数据库是因为表太多而造成海量数据，并且项目的各项业务逻辑划分清晰、低耦合，那么规则简单明了、容易实施的垂直切分必是首选。

而如果数据库中的表并不多，但单表的数据量很大、或数据热度很高，这种情况之下就应该选择水平切分，水平切分比垂直切分要复杂一些，它将原本逻辑上属于一体的数据进行了物理分割，除了在分割时要对分割的粒度做好评估，考虑数据平均和负载平均，后期也将对项目人员及应用程序产生额外的数据管理负担。

在现实项目中，往往是这两种情况兼而有之，这就需要做出权衡，甚至既需要垂直切分，又需要水平切分。我们的游戏项目便综合使用了垂直与水平切分，我们首先对数据库进行垂直切分，然后，再针对一部分表，通常是用户数据表，进行水平切分。

---

### 设计相关概念

**数据库设计范式(NF)**

1. 第一范式: 指数据库表的每一列都是不可分割的基本数据项.
2. 第二范式: 数据库表中不存在非关键字段对任一候选键的部分函数依赖，也即所有非关键字 段都完全依赖于任意一组候选关键字.
3. 第三范式: 在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式.
4. BCNF范式：Boyce-Codd Normal Form的简称。数据表中如果不存在主属性对候选主键的部分或传递依赖关系，则符合BCNF范式.换个说法就是：如果属性B依赖属性A，属性A必须是候选主键。

> 第一范式是对属性原子性的约束，要求属性具有原子性，不可再分割；
第二范式是对记录唯一性的约束，要求记录有唯一标识，即实体的唯一性；
第三范式是对冗余字段的约束，即任何字段不能由其他字段派生而来；
BCNF范式是消除了属性(二三范式说的是非主属性；BCNF说的主属性)对候选主键的部分和传递依赖关系。例如一张表中有三个字段：学号、课程和教授，候选主键为：学号和课程。满足第一、第二和第三范式，但是不满足BCNF范式。原因是：课程依赖教授，课程是主属性，而教授是非主属性。

**冗余设计**

数据库冗余:存储两倍数据,使系统速度更快(减少联查).

> 在设计数据库时，某一字段属于一个表，但它又同时出现在另一个或多个表，且完全等同于它在其本来所属表的意义表示，那么这个字段就是一个冗余字段。

创建关系型数据库时,有两种选择:

1. 尽量遵循范式理论的规约，尽可能少的冗余字段，让数据库设计看起来精致、优雅、让人心醉。
2. 合理的加入冗余字段这个润滑剂，减少join，让数据库执行性能更高更快。

### 数据库设计示例

*用户登录系统：*

用户的基本信息表(USER)：`id(PK) | nickname(昵称) | avatar(头像)`

用户授权信息表(USER-AUT)：`id(PK) | user_id(外键-USER) | identity_id(登录类型) | identifier(标识-手机号、邮箱、第三方登录OpenID等) | credential(密码凭证-站内保存密码站外不保存或者保存token)`

*权限管理系统：*

![权限管理系统设计](/img/posts/privilege-design.png)

> 某某主体 在 某某领域 有 某某权限
1. 主体可以是用户，可以是角色，也可以是一个部门(Master)
2. 领域可以是一个模块，可以是一个页面，也可以是页面上的按钮(Access)
3. 权限可以是“可见”，可以是“只读”，也可以是“可用”(如按钮可以点击)(Operation)

*微博数据库设计：*

![用户信息表](img/t_user_info.png)

> 用户信息表。

![用户之间的关系表](img/t_user_relation.png)

> 用户之间的关系表。
之所以要定义类型为关注和粉丝，是为了分表方便。

![消息元数据表](img/t_msg_info.png)

> 消息元数据表。

![用户消息索引表](img/t_user_msg_index.png)

> 用户消息索引表。

![消息与消息之间的关系表](img/t_msg_msg_relation.png)

> 消息与消息之间的关系表。

*数据库实体关系图：*

![数据库实体关系图](img/date-modeling.png)

*业务逻辑：*

> A关注B：
1. 在t_user_relation_A中添加`A B 1`
2. 在t_user_relation_B中添加`B A 0`

> 原创发消息：
1. 在t_msg_info_A中添加这条元消息，type为0(原创)
2. 更新t_user_info_A中Msg_count
3. 在t_uer_msg_index_A中插入A发的这条消息的索引（A的编号和消息编号）
4. 在t_user_relation_A中找到所有关注A的人，比如B,C,D,E,F等等。并发在这些用户的t_uer_msg_index中插入A的这条信息索引，比如名人微博可以并发多个进程来实现对粉丝的消息同步。

> A转发B的消息msg_b：
1. 在t_msg_info_A中添加这条元消息msg_a，type为2(转发)
2. 更新t_user_info_A中Msg_count
3. 在t_uer_msg_index_A中插入A发的这条消息的索引（A的编号和消息编号）。如果转发消息希望粉丝能够看到，需要在t_user_relation_A中找到粉丝，更新t_user_msg_index中这些用户的用户消息索引。
4. 在t_msg_info_B中更新msg_b的Transferred_count和Transfer_count
5. 在t_msg_msg_relation中添加User_a,msg_a与User_b，msg_b的转发关系，page_index为Transferred_count%page_count

> A评论B的消息msg_b：
1. 在t_msg_info_A中添加这条元消息msg_a，type为1
2. 更新t_user_info_A中Msg_count
3. 在t_uer_msg_index_A中插入A发的这条消息的索引（A的编号和消息编号）
4. 在t_msg_info_B中更新msg_b的Commented_count和Comment_count
5. 在t_msg_msg_relation中添加User_a,msg_a与User_b，msg_b的评论关系，page_index为Commented_count%page_count

> A删除msg_a：
1. 删除t_msg_info中的元数据msg_a
2. 删除t_uer_msg_index_A中的User_a，msg_a行记录。粉丝如果查不到改消息，应该提示“原消息已被作者删除”或者只做不显示处理
3. 备注：如果A的msg_a被别人评论或者引用，那么在对方查看评论或者转发的时候会提示“原消息已被作者删除”

> A删除转发消息msg_a：
1. 删除t_msg_info_A中的元数据msg_a
2. 删除t_uer_msg_index_A中的User_a，msg_a行记录
3. 在t_msg_msg_relation_A表中找到msg_a的源消息，即B的msg_b
4. 删除t_msg_msg_relation_A中user_a，msg_a和user_b，msg_b的转发关系
5. 更新t_msg_info_B中msg_b记录的Transfer_count，减1

> A删除评论消息msg_a：
1. 删除t_msg_info_A中的元数据msg_a
2. 删除t_uer_msg_index_A中的User_a，msg_a行记录
3. 在t_msg_msg_relation_A表中找到msg_a的源消息，即B的msg_b
4. 删除t_msg_msg_relation_A中user_a，msg_a和user_b，msg_b的评论关系
5. 更新t_msg_info_B中msg_b记录的Commecnt_count，减1

> A拉取全部消息：
1. 从t_uer_msg_index_A中拉取Author_id，Msg_id，Time_t索引，并以Time_t排序
2. 通过页码和每页count控制返回结果数量，这样避免了server io 压力冲击

### 数据库设计注意事项

*主键：*

1. 主键应当是对用户没有意义的;
2. 主键应当是单列的。如果要实现多对多关系的连接表，最好也不要用两个外键组合作为连接表的主键，而是应该给这个连接表定义一个主键。

---
